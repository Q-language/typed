---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# typed

*{typed}* implements static typing in R, it has 3 main features:

* set variable types in a script or the body of a function
* set argument types in a function definition
* set return type of a function

The user can define their own types, or leverage check functions from
other packages such as assertions from Richie Cotton's *{assertive}* package.

Under the hood we use active bindings, so once a variable is restricted to
a type, or by any other condition, it cannot be modified in a way that would
not respect these restrictions.

## Installation

Install with:

``` r
remotes::install_github("moodymudskipper/typed")
```

And attach with : 

```{r}
# masking warning about overriding `?`
library(typed, warn.conflicts = FALSE) 
```

## Set variable type

### Question mark notation and `declare`

Here are examples on how we would set types 

```{r}
Character() ? x # restrict x to "character" type
x <- "a"
x
Integer(3) ? y <- 1:3 # restrict y to "integer" type of length 3
y
```

We cannot assign values of the wrong type to `x` and `y` anymore.

```{r}
x <- 2
y <- 4:5
y[1] <- 10
```

But the right type will work.

```{r}
x <- c("b", "c")
y <- c(1L, 10L, 100L)
```

If you dislike the `?` operator you can use `declare`, it's a strict equivalent,
slightly more efficient, which looks like `base::assign`.

```{r}
declare("x", Character())
x <- "a"
x
declare("y", Integer(3), 1:3)
y
```

### Type checkers and assertions

`Integer` and `Character` are called type checkers.

The package contains many of those (see `?native_types`), the main ones are: 

* `Any` (No default restriction)
* `Logical`
* `Integer`
* `Double`
* `Character`
* `List`
* `Environment`
* `Factor`
* `Matrix`
* `Data.frame`
* `Date`
* `Time` (POSIXct)

They are function factories (functions that return functions),
thus `Integer(3)` and `Character()` are functions. 

In particular these functions operate checks on a value and in case of success 
return this value, generally unmodified. For instance :

```{r}
Data.frame()(letters)
Data.frame(ncol = 5)(cars)
```

We use the denomination used by the *{assertive}* package and call these functions
assertions.

### Custom types 

As we've seen with `Integer(3)`, `Data.frame(ncol = 5)`, passing arguments to a
type checker restricts the type. For instance `Integer` has arguments `length` and
`...`, in the dots we can use arguments named as functions and with the value of
the expected result.

```{r}
Integer(anyNA = FALSE) ? x <- c(1L, 2L, NA)
```

That makes type checkers very flexible! If it is still not flexible enough, one
can provide conditions using formulas.

```{r}
fruit <- Character(1, "`value` is not a fruit!" ~ . %in% c("apple", "pear", "cherry"))
fruit ? x <- "potatoe"
```

We can also use assertions from other packages. For instance

```{r}
library(assertive)

# used without type definition
assert_is_monotonic_increasing(1:3)
assert_is_monotonic_increasing(3:1)

# used with type definition
assert_is_monotonic_increasing ? z
z <- 1:3 # works
z <- 3:1 # fails
```

Finally, custom type checkers can be defined using the function `new_type_checker`, 
[check my code on github to understand how to create them](https://github.com/moodymudskipper/typed/blob/iteration2/R/06_native_types.R)


## Set argument type

We can set argument types this way : 


```{r}
add <- ? function (x= ? Double(), y= 1 ? Double()) {
  x + y
}
```

Note that we started the definition with a `?`, and that we gave a default to
`y`, but not `x`

This created the following function, by adding declarations at the top of the
function.

```{r}
add
```

Note that a declaration will fail if the variable already exists in the
environment, but an exception is made for unevaluated function arguments.

Let's test it by assigning a right and wrong type

```{r}
add(2, 3)
add(2, 3L)
```

Arguments `x` and `y` will also be restricted to the type "integer" in the rest of
the body of the function.


## Set function return type

To set a return type, we give a left hand side to the `?` that precedes the function
definition.

```{r}
add_or_substract <- Double() ? function (x, y, substract = FALSE) {
  if(substract) return(x - y)
  x + y
}
add_or_substract
```

We see that the last call and the return call were edited to call the appropriate
assertion on the output :

```{r}
add_or_substract(1, 2)
add_or_substract(1L, 2L)
```

Due to `?`'s precedence, when defining the function in a package, in order

These can be defined in a package and documented with *{roxygen2}* like regular
functions, except that you'll need to make sure to add the `@name` tag (it's due
to `?`'s precedence). for instance :

```{r, eval = FALSE}
#' add
#'
#' @param x double
#' @param y double
#' @export
#' @name add
add <- Double() ? function (x = ? Double(), y = 1 ? Double()) {
  x + y
}
```


## Notes

* This is inspired in good part by Jim Hester and Gabor Csardi's work.
* The magic comes from the fact that apparent variables are made into active
  bindings, using a variation of the last example of `?bindenv`
* Your package would import *{typed}* but `?` won't be exposed to the user,
they will see it in the code but will be able to use `?` just as before. In fact
the most common standard use `?mean` still works even when *{typed}* is attached.
